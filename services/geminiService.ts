
import { GoogleGenAI, GenerateContentResponse } from "@google/genai";
import { GenerationMode, ModificationTask, ModificationResult } from "../types";

const getAI = () => new GoogleGenAI({ apiKey: process.env.API_KEY || '' });

/**
 * Compresses a base64 image to target a specific size range (approx 700-900k)
 * by re-encoding as JPEG with adjusted quality.
 */
const compressImage = async (base64: string): Promise<string> => {
  return new Promise((resolve) => {
    const img = new Image();
    img.onload = () => {
      const canvas = document.createElement('canvas');
      canvas.width = img.width;
      canvas.height = img.height;
      const ctx = canvas.getContext('2d');
      if (!ctx) return resolve(base64);
      ctx.drawImage(img, 0, 0);
      // 0.8 quality typically lands 16:9 images in the 700k-900k range
      resolve(canvas.toDataURL('image/jpeg', 0.8));
    };
    img.src = base64;
  });
};

/**
 * Utility to wait for a specific duration
 */
const sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

/**
 * Analyzes user instructions using a Flash-tier text model (gemini-3-flash-preview).
 * This helps refine the prompt before sending it to the image model.
 */
export const parseInstructions = async (image: string, prompt: string) => {
  const ai = getAI();
  const model = 'gemini-3-flash-preview'; // Using Flash tier for text tasks
  
  const textPart = {
    text: `You are an expert image editor. The user instruction is: "${prompt}". 
    Summarize this into a clear, concise technical prompt for an AI image generation model. 
    Focus on specific visual changes. Language: English.`
  };
  
  const imagePart = {
    inlineData: {
      mimeType: 'image/jpeg',
      data: image.split(',')[1]
    }
  };

  try {
    const response = await ai.models.generateContent({
      model,
      contents: { parts: [imagePart, textPart] }
    });
    return response.text || prompt;
  } catch (error) {
    console.warn("Instruction parsing skipped due to quota or error, using original prompt.", error);
    return prompt;
  }
};

/**
 * Internal generation logic with retry and exponential backoff.
 * Uses 'gemini-2.5-flash-image' which is the Flash-tier image generation model.
 */
const generateWithRetry = async (
  task: ModificationTask,
  mode: GenerationMode,
  retries = 3,
  delay = 2000
): Promise<ModificationResult> => {
  const ai = getAI();
  const model = 'gemini-2.5-flash-image'; // Already using the Flash image model
  
  const randomSeed = Math.random().toString(36).substring(7);
  const realismKeywords = "photorealistic real-life photography, professional DSLR shot, raw photo, natural lighting, highly detailed textures, authentic shadows, 8k resolution realism, no concept art, no 3d render";
  
  let augmentedPrompt = "";
  switch (mode) {
    case GenerationMode.LOCAL_EDIT:
      augmentedPrompt = `[PATH: PRECISE REALITY] Instruction: "${task.prompt}". Realistic local edit, maintain everything else perfectly. STYLE: ${realismKeywords}. SEED: ${randomSeed}`;
      break;
    case GenerationMode.PERSPECTIVE:
      augmentedPrompt = `[PATH: DYNAMIC ANGLE] Instruction: "${task.prompt}". Perspective: ${task.perspectiveAngle || 'new cinematic angle'}. STYLE: ${realismKeywords}. SEED: ${randomSeed}`;
      break;
    case GenerationMode.SCENE_SWAP:
      augmentedPrompt = `[PATH: ENVIRONMENT MIGRATION] Instruction: "${task.prompt}". Scene: ${task.sceneType || 'new real-world setting'}. STYLE: ${realismKeywords}. SEED: ${randomSeed}`;
      break;
    case GenerationMode.COMPREHENSIVE:
      augmentedPrompt = `[PATH: FULL TRANSFORMATION] Overhaul "${task.prompt}" with ${task.perspectiveAngle || 'new perspective'} in ${task.sceneType || 'new environment'}. STYLE: ${realismKeywords}. SEED: ${randomSeed}`;
      break;
  }

  const imagePart = {
    inlineData: {
      mimeType: 'image/jpeg',
      data: task.originalImage.split(',')[1]
    }
  };

  try {
    const response = await ai.models.generateContent({
      model,
      contents: { parts: [imagePart, { text: augmentedPrompt }] },
      config: { imageConfig: { aspectRatio: "16:9" } }
    });

    let imageUrl = '';
    const parts = response.candidates?.[0]?.content?.parts || [];
    for (const part of parts) {
      if (part.inlineData) {
        imageUrl = `data:${part.inlineData.mimeType};base64,${part.inlineData.data}`;
        break;
      }
    }

    if (!imageUrl) throw new Error("No image generated by model");
    const compressedUrl = await compressImage(imageUrl);

    return {
      id: Math.random().toString(36).substring(7),
      url: compressedUrl,
      mode,
      promptUsed: augmentedPrompt,
      timestamp: Date.now()
    };
  } catch (error: any) {
    const isRateLimit = error?.message?.includes('429') || error?.message?.includes('RESOURCE_EXHAUSTED');
    if (isRateLimit && retries > 0) {
      console.warn(`Rate limit hit for ${mode}. Retrying in ${delay}ms... (${retries} left)`);
      await sleep(delay);
      return generateWithRetry(task, mode, retries - 1, delay * 2);
    }
    throw error;
  }
};

export const generateVariant = async (
  task: ModificationTask,
  mode: GenerationMode
): Promise<ModificationResult> => {
  // Add a small initial stagger to prevent simultaneous burst requests
  const stagger = Math.random() * 1000;
  await sleep(stagger);
  return generateWithRetry(task, mode);
};
